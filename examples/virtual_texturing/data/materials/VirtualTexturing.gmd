{
  "vertex_methods" :
  [],

  "fragment_methods" :
  [
    {
      "name" : "FragmentColor",
      "source" : "
        // color generation ----------------------------------------------------
        void FragmentColor() {

          //swap y axis
          vec3 texture_coordinates = vec3(gl_FragCoord.xy / vec2(gua_resolution), 0.0);
          texture_coordinates.y = 1.0 - texture_coordinates.y;

          //index xyzw into idxquadruple
          uvec4 idx_quadruple = texture(usampler2D(ColorMap), texture_coordinates.xy).rgba;
          texture_coordinates.z = idx_quadruple.w;

          uint current_level = idx_quadruple.z;
          // exponent for calculating the occupied pixels in our index texture, based on which level the tile is in
          uint tile_occupation_exponent = max_level_color - current_level;


          // 2^tile_occupation_exponent defines how many pixel (of the index texture) are used by the given tile
          uint occupied_index_pixel_per_dimension = uint(1 << tile_occupation_exponent);

          // offset represented as tiles is divided by total num tiles per axis
          // (replace max_width_tiles later by correct uniform)
          // extracting x,y from index texture
          uvec2 base_xy_offset = idx_quadruple.xy;


          // just to be conformant to the modf interface (integer parts are ignored)
          vec2 dummy;


          // base x,y coordinates * number of tiles / number of used index texture pixel
          // taking the factional part by modf
          vec2 physical_tile_ratio_xy = modf((texture_coordinates.xy * index_dim_color / vec2(occupied_index_pixel_per_dimension)), dummy);


          // Use only tile_size - 2*tile_padding pixels to render scene
          // Therefore, scale reduced tile size to full size and translate it
          vec2 padding_scale = 1 - 2 * tile_padding / tile_size;
          vec2 padding_offset = tile_padding / tile_size;


          // adding the ratio for every texel to our base offset to get the right pixel in our tile
          // and dividing it by the dimension of the phy. tex.
          vec2 physical_texture_coordinates = (base_xy_offset.xy + physical_tile_ratio_xy * padding_scale + padding_offset) / physical_texture_dim;


          //outputting the calculated coordinate from our physical texture
          vec4 color = texture(sampler2DArray(PhysicalTexture2D), vec3(gua_texcoords, 0));

          // feedback calculation based on accumulated use of each rendered tile
          //uint one_d_feedback_ssbo_index = base_xy_offset.x + base_xy_offset.y * physical_texture_dim.x + idx_quadruple.w * physical_texture_dim.x * physical_texture_dim.y;

          //buffer missing output uniform quatsch
          //atomicAdd(out_feedback_values[one_d_feedback_ssbo_index], 1);


          /*
          uvec4 idx = texture(usampler2D(ColorMap), gua_texcoords).rgba;
          vec3 gua_vec3_texcoords = vec3(0.0, 0.0, 0.0);
          vec4 color = texture(sampler2DArray(PhysicalTexture2D), gua_vec3_texcoords);
          vec4 color = texture(sampler2DArray(PhysicalTexture2D), texture_coordinates);
          unit tile_occupation_exponent = max_level_color - current_level;
          */

          gua_alpha = 1.0;
          gua_metalness = 0.0;
          gua_emissivity = 1.0;


          //gua_color = color.rgb / 1.0;
          gua_color = texture(sampler2DArray(PhysicalTexture2D), texture_coordinates).rgb;
            


            //OUTPUT????????? layout(std430, binding = 0) buffer out_feedback { uint[] out_feedback_values; };
        }
      ",
      "uniforms" :
      [
        {
          "name" : "ColorMap",
          "type" : "usampler2D",
          "value" : "0"
        },
	     {
	       "name"  : "PhysicalTexture2D",
	       "type"  : "sampler2DArray",
	       "value" : "0"
	     },
       {
        "name"  : "max_level_color",
        "type"  : "int",
        "value" : "0"
       },
       {
        "name"  : "tile_size",
        "type"  : "vec2",
        "value" : "0"
       },
       {
        "name"  : "tile_padding",
        "type"  : "vec2",
        "value" : "0"
       },
       {
        "name"  : "physical_texture_dim",
        "type"  : "vec2ui",
        "value" : "(1.0 1.0)"
       },
       {
        "name"  : "index_dim_color",
        "type"  : "vec2ui",
        "value" : "(1.0 1.0)"
       }
      ]
    }
    ]
}
